/**
 * @file swclock_event_dump.c
 * @brief SwClock event log binary dump tool
 *
 * Reads binary event log files generated by SwClock event logging and
 * converts them to human-readable text format.
 *
 * Usage: swclock_event_dump <event_log.bin> [output.txt]
 *        If output.txt is omitted, writes to stdout
 *
 * @author SwClock Development Team
 * @date 2025-01-19
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include <errno.h>
#include "../src/sw_clock/sw_clock_events.h"

/**
 * @brief Print formatted timestamp
 */
static void print_timestamp(FILE* out, uint64_t ns_since_epoch) {
    time_t sec = ns_since_epoch / 1000000000ULL;
    uint64_t ns = ns_since_epoch % 1000000000ULL;
    struct tm tm_val;
    gmtime_r(&sec, &tm_val);
    fprintf(out, "%04d-%02d-%02d %02d:%02d:%02d.%09llu",
            tm_val.tm_year + 1900, tm_val.tm_mon + 1, tm_val.tm_mday,
            tm_val.tm_hour, tm_val.tm_min, tm_val.tm_sec, ns);
}

/**
 * @brief Print event header
 */
static void print_event_header(FILE* out, swclock_event_header_t* hdr) {
    fprintf(out, "[%010llu] ", hdr->sequence_num);
    print_timestamp(out, hdr->timestamp_ns);
    fprintf(out, " | %-20s | ", swclock_event_type_name(hdr->event_type));
}

/**
 * @brief Print adjtime event payload
 */
static void print_adjtime_payload(FILE* out, swclock_event_adjtime_payload_t* p) {
    fprintf(out, "modes=0x%04x offset=%lld ns freq=%lld scaled_ppm return=%d",
            p->modes, p->offset_ns, p->freq_scaled_ppm, p->return_code);
}

/**
 * @brief Print PI step event payload
 */
static void print_pi_step_payload(FILE* out, swclock_event_pi_step_payload_t* p) {
    fprintf(out, "freq=%.3f ppm int_error=%.9f s phase=%lld ns enabled=%d",
            p->pi_freq_ppm, p->pi_int_error_s, p->remaining_phase_ns, p->servo_enabled);
}

/**
 * @brief Print phase slew event payload
 */
static void print_phase_slew_payload(FILE* out, swclock_event_phase_slew_payload_t* p) {
    fprintf(out, "target=%lld ns current=%lld ns rate=%.3f ns/s duration=%u ms",
            p->target_phase_ns, p->current_phase_ns, p->slew_rate_ns_per_s, p->duration_ms);
}

/**
 * @brief Print frequency clamp event payload
 */
static void print_frequency_clamp_payload(FILE* out, swclock_event_frequency_clamp_payload_t* p) {
    fprintf(out, "requested=%.3f ppm clamped=%.3f ppm max=%.3f ppm",
            p->requested_ppm, p->clamped_ppm, p->max_ppm);
}

/**
 * @brief Print generic event payload as hex dump
 */
static void print_hex_dump(FILE* out, uint8_t* data, uint32_t size) {
    for (uint32_t i = 0; i < size; i++) {
        fprintf(out, "%02x ", data[i]);
        if ((i + 1) % 16 == 0) fprintf(out, "\n                                                     ");
    }
}

/**
 * @brief Process event log file
 */
static int process_event_log(FILE* in, FILE* out) {
    // Read and validate file header
    swclock_event_log_header_t file_hdr;
    if (fread(&file_hdr, sizeof(file_hdr), 1, in) != 1) {
        fprintf(stderr, "Error: Failed to read file header\n");
        return -1;
    }

    if (file_hdr.magic != SWCLOCK_EVENT_LOG_MAGIC) {
        fprintf(stderr, "Error: Invalid magic number (expected 0x%08x, got 0x%08x)\n",
                SWCLOCK_EVENT_LOG_MAGIC, file_hdr.magic);
        return -1;
    }

    // Print file header
    fprintf(out, "=== SwClock Event Log ===\n");
    fprintf(out, "Format Version: %u.%u\n", file_hdr.version_major, file_hdr.version_minor);
    fprintf(out, "SwClock Version: %s\n", file_hdr.swclock_version);
    fprintf(out, "Start Time: ");
    print_timestamp(out, file_hdr.start_time_ns);
    fprintf(out, "\n");
    fprintf(out, "\n");
    fprintf(out, "%-12s %-30s   %-20s   %s\n", "Sequence", "Timestamp", "Event Type", "Payload");
    fprintf(out, "------------ ------------------------------ -------------------- --------------\n");

    // Read events
    uint64_t event_count = 0;
    while (!feof(in)) {
        // Read event header
        swclock_event_header_t evt_hdr;
        size_t nread = fread(&evt_hdr, sizeof(evt_hdr), 1, in);
        if (nread == 0) break;  // End of file
        if (nread != 1) {
            fprintf(stderr, "Warning: Incomplete event header at offset %ld\n", ftell(in) - sizeof(evt_hdr));
            break;
        }

        // Validate event type (use a reasonable maximum)
        if (evt_hdr.event_type >= 0xFF) {
            fprintf(stderr, "Warning: Invalid event type %u at sequence %llu\n",
                    evt_hdr.event_type, evt_hdr.sequence_num);
            break;
        }

        // Print event header
        print_event_header(out, &evt_hdr);

        // Read and print payload
        if (evt_hdr.payload_size > 0) {
            uint8_t payload_buf[256];  // Max payload size
            if (evt_hdr.payload_size > sizeof(payload_buf)) {
                fprintf(stderr, "Error: Payload size %u exceeds maximum\n", evt_hdr.payload_size);
                break;
            }

            if (fread(payload_buf, evt_hdr.payload_size, 1, in) != 1) {
                fprintf(stderr, "Warning: Failed to read payload at sequence %llu\n", evt_hdr.sequence_num);
                break;
            }

            // Interpret payload based on event type
            switch (evt_hdr.event_type) {
                case SWCLOCK_EVENT_ADJTIME_CALL:
                case SWCLOCK_EVENT_ADJTIME_RETURN:
                    print_adjtime_payload(out, (swclock_event_adjtime_payload_t*)payload_buf);
                    break;
                case SWCLOCK_EVENT_PI_STEP:
                    print_pi_step_payload(out, (swclock_event_pi_step_payload_t*)payload_buf);
                    break;
                case SWCLOCK_EVENT_PHASE_SLEW_START:
                case SWCLOCK_EVENT_PHASE_SLEW_DONE:
                    print_phase_slew_payload(out, (swclock_event_phase_slew_payload_t*)payload_buf);
                    break;
                case SWCLOCK_EVENT_FREQUENCY_CLAMP:
                    print_frequency_clamp_payload(out, (swclock_event_frequency_clamp_payload_t*)payload_buf);
                    break;
                default:
                    print_hex_dump(out, payload_buf, evt_hdr.payload_size);
                    break;
            }
        }

        fprintf(out, "\n");
        event_count++;
    }

    fprintf(out, "\n=== Total Events: %llu ===\n", event_count);
    return 0;
}

/**
 * @brief Main entry point
 */
int main(int argc, char** argv) {
    if (argc < 2 || argc > 3) {
        fprintf(stderr, "Usage: %s <event_log.bin> [output.txt]\n", argv[0]);
        fprintf(stderr, "  If output.txt is omitted, writes to stdout\n");
        return 1;
    }

    const char* input_file = argv[1];
    FILE* in = fopen(input_file, "rb");
    if (!in) {
        fprintf(stderr, "Error: Failed to open input file '%s': %s\n",
                input_file, strerror(errno));
        return 1;
    }

    FILE* out = stdout;
    if (argc == 3) {
        out = fopen(argv[2], "w");
        if (!out) {
            fprintf(stderr, "Error: Failed to open output file '%s': %s\n",
                    argv[2], strerror(errno));
            fclose(in);
            return 1;
        }
    }

    int ret = process_event_log(in, out);

    fclose(in);
    if (out != stdout) {
        fclose(out);
    }

    return ret;
}
